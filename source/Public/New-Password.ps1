function New-Password
{
    <#
        .DESCRIPTION
            Function that generates passwords
        .PARAMETER Simple
            Specifies that the function will create a password according to the following ruleset

            The first characters is a captial consonant letter
            The second character is a lower vowel letter
            The third character is a lower consonant letter
            The fourth character is lower vowel letter
            The remaining four characters are digits.

            This structure creates a password that is easy to remember but is less secure. What
            makes the password easier to remember is that the most character combinations are
            reasonably easy to prenounce. These password should only be used temporary. An
            few examples might be:

            Wodi6380
            Jaki2830
            Kezo2617
        .PARAMETER Count
            Defines the number of passwords to generate. This can be used to create batches of passwords. Defaults to 1.
        .PARAMETER Length
            When the parameter set custom is used this parameter lets the user select
            how long the password should be. Defaults to 8.
        .PARAMETER Signs
            When the parameter set custom is used this parameter lets the user select
            how many signs/symbols that should be included in the password. Defaults to 3.
        .PARAMETER ReturnSecureStringObject
            Return password as secure string
        .PARAMETER Custom
            Defines a custom rule for password selection
        .PARAMETER AllowInterchangableCharacters
            Defines that characters as i|I and l|L and 0|O can be used in the password, defaults to false
        .PARAMETER Diceware
            Defines that a diceware password should be generated
        .PARAMETER WordCount
            Defines how many words the diceware password should made up of
        .PARAMETER CustomFirstWord
            Optionally define a custom first word of the diceware series.
        .EXAMPLE
            New-Password -Diceware -WordCount 5 -Count 3

            robust.dawn\condense/poet#cost
            parchment\parcel:remedy:ultra'triage
            spelling,mooned*propeller%legwarmer*flagstick

        .EXAMPLE
            New-Password -Diceware -WordCount 5 -Count 3 -CustomFirstWord 'gardin'

            gardin\throwback"chirping#remake"poem
            gardin#juvenile!putt\jittery.palatable
            gardin'astonish\decaf"imprudent?specimen

        .EXAMPLE
            New-Password -Simple -Count 3

            Wuba9710
            Suve0945
            Zigo1479

            This example uses the method to create a password that is easy to remember but less secure.
        .EXAMPLE
            New-Password -Length 10 -Signs 5

            ..&La:J%NF

            This example creates a password of alphanumrerical characters including five signs/symbols.
        .EXAMPLE
            New-Password -Length 20

            J.rp318xVD?Twhah'K7b

            This example creates a password of alpanumerical+signs characters
    #>
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseShouldProcessForStateChangingFunctions', '', Justification = 'No need, non-destructive change')]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidUsingConvertToSecureStringWithPlainText', '', Justification = 'FalsePositive, plain text string is generated by the script')]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSReviewUnusedParameter', '', Justification = 'False positive')]
    [CmdletBinding(DefaultParameterSetName = 'Simple')]
    param(
        [Parameter(ParameterSetName = 'Custom')]
        [ValidateRange(0, 128)][int]$Length = 12,

        [Parameter(ParameterSetName = 'Custom')]
        [int]$Signs = 3,

        [int]$Count = 1,

        [Parameter(ParameterSetName = 'Custom')]
        [switch]$Custom,

        [switch]$ReturnSecureStringObject,

        [switch]$AllowInterchangableCharacters,

        [Parameter(ParameterSetName = 'diceware')]
        [ValidateRange(2, 256)]
        [int]$WordCount = 4,

        [Parameter(ParameterSetName = 'diceware')]
        [switch]
        $Diceware,

        [Parameter(ParameterSetName = 'diceware')]
        [string]
        $CustomFirstWord

    )

    function ThrowDice
    {
        $String = ''
        for ($i = 0; $i -lt 5; $i++)
        {
            if ($PSVersionTable.PSEdition -eq 'core')
            {
                $String += ([System.Security.Cryptography.RandomNumberGenerator]::GetInt32(1, 7)).ToString()
            }
            else
            {
                $String += (Get-Random -Minimum 1 -Maximum 7).ToString()
            }
        }
        return ($String -as [int])
    }

    function SelectDiceWord
    {
        param (
            [ref]$WordListHash
        )
        return ($WordListHash.Value[(ThrowDice).ToString()])
    }

    function SelectRandomSign
    {
        param (
            [char[]]$Signs
        )
        if ($PSVersionTable.PSEdition -eq 'core')
        {
            return ($Signs[([System.Security.Cryptography.RandomNumberGenerator]::GetInt32(0, ($Signs.Count)))])
        }
        else
        {
            return ($Signs[(Get-Random -Minimum 0 -Maximum ($Signs.Count))])
        }
    }

    $Arrays = @{
        LettersAndDigits = [char[]]@(48..57 + 65..90 + 97..122)
        Signs            = [char[]]@(33..35 + 37..39 + 42 + 44 + 46..47 + 58..59 + 63..64 + 92)
        Digits           = [char[]]@(48..57)
        UpperConsonants  = [char[]]@('B', 'C', 'D', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'X', 'Z', 'W', 'Y')
        LowerConsonants  = [char[]]@('b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l' , 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'x', 'z', 'w', 'y')
        LowerVowels      = [char[]]@('a', 'e', 'i', 'o', 'u')
    }

    if ($PSCmdlet.ParameterSetName -eq 'diceware')
    {
        $WordListHash = @{}
        Import-Csv (Resolve-Path "$PSScriptRoot\include\eff_large_wordlist.txt") -Delimiter "`t" -Header 'Dice', 'Word' | ForEach-Object {
            $WordListHash.Add($PSItem.Dice, $PSItem.Word)
        }
    }

    if (-not $AllowInterchangableCharacters)
    {
        $InterchangableCharacters = @(
            [char]'l', [char]'I', [char]'O', [char]'o', [char]48
        )
        # Clone keys from hashtable so that the hashtable can be modified during enumeration
        $Arrays.Keys.Clone() | ForEach-Object {
            $CurrentArrayKey = $PSItem
            $Arrays[$CurrentArrayKey] = $Arrays[$CurrentArrayKey] | Where-Object { $InterchangableCharacters -notcontains $PSItem }
        }
    }

    if ($Signs -gt $Length)
    {
        Write-Warning ('Sign characters cannot be greater than the length, setting Signs to the specified length ({0})' -f $Length)
        $Signs = $Length
    }

    1..$Count | ForEach-Object {
        switch ($PSCmdlet.ParameterSetName)
        {
            'Simple'
            {
                $CharArray = [char[]]@()
                $CharArray += ($Arrays.UpperConsonants | Get-Random -Count 1)
                $CharArray += ($Arrays.LowerVowels | Get-Random -Count 1)
                $CharArray += ($Arrays.LowerConsonants | Get-Random -Count 1)
                $CharArray += ($Arrays.LowerVowels | Get-Random -Count 1)
                $CharArray += ($Arrays.LowerConsonants | Get-Random -Count 1)
                $CharArray += ($Arrays.LowerVowels | Get-Random -Count 1)
                $CharArray += ($Arrays.Digits | Get-Random -Count 5)

                $PasswordString = $CharArray -join ''
            }
            'Custom'
            {
                $CharArray = [char[]]@()
                $NumberOfChars = $Signs
                1..$Length | ForEach-Object {
                    $CurrentChar = $_
                    $Decider = Get-Random -Minimum 0 -Maximum 100
                    $CharsLeft = ($Length + 1 - $CurrentChar)
                    $Chance = ($NumberOfChars / $CharsLeft * 100)
                    if ($Decider -lt $Chance -or $CharsLeft -le $NumberOfChars)
                    {
                        $CharArray += ($Arrays.Signs | Get-Random -Count 1)
                        $NumberOfChars--
                    }
                    else
                    {
                        $CharArray += ($Arrays.LettersAndDigits | Get-Random -Count 1)
                    }
                }
                $PasswordString = $CharArray -join ''
            }
            'diceware'
            {
                $PasswordString = ''

                if ($CustomFirstWord)
                {
                    if ($WordListHash.ContainsValue($CustomFirstWord))
                    {
                        Write-Warning -Message 'The chosen first word is already included in the diceware word list, please select another word.'
                    }
                    $PasswordString += $CustomFirstWord
                }
                else
                {
                    $PasswordString += SelectDiceWord -WordListHash ([ref]$WordListHash)
                }

                1..($WordCount - 1) | ForEach-Object {
                    $PasswordString += SelectRandomSign -Signs $Arrays.Signs
                    $PasswordString += SelectDiceWord -WordListHash ([ref]$WordListHash)
                }

            }
        }
        if ($ReturnSecureStringObject)
        {
            ConvertTo-SecureString -String $PasswordString -AsPlainText -Force
        }
        else
        {
            $PasswordString
        }

    }
}
